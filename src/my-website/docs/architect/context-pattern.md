---
sidebar_position: 1
---

# 上下文模式
這個「The Context Pattern」（上下文模式）其實是一個帶有幽默和諷刺味道的程式設計概念，來自一位有豐富函數式程式語言經驗的開發者（用了8年Haskell、2年OCaml、2.5年C++，然後只用了45分鐘Go就「頓悟」了）。
核心想法是什麼？
它就是：创建一个單一的記錄（record，或稱struct）來存放所有的依賴（dependencies），然後明確地（explicitly）把這個記錄傳遞給每一個函數。

## 簡單來說：
*  你把應用程式需要的各種服務、資料庫連線、logger、配置等，所有外部依賴都打包進一個結構體（在Go裡就是struct，在Haskell/OCaml裡就是record）。
*  每當函數需要這些依賴時，你不是用全域變數、單例（singleton）、依賴注入框架（DI container），也不是繼承或類別方法，而是直接把這個「上下文」物件當作參數傳進去。
*  所有函數都變成純函數（pure function）風格：輸入資料 + 這個上下文 → 輸出結果。

## 為什麼說它是「終極設計模式」？
作者用誇張的語氣宣稱這結合了：
*  函數式程式設計（FP）：依賴明確傳遞，避免隱藏狀態，容易測試和推理。
*  物件導向（OOP）：不用繼承、不用類別方法、不用private/public（因為一切都是資料）。
*  程序式：簡單直接傳參數。
*  宣告式：聚焦在「什麼」而不是「怎麼」。
它解決了很多傳統模式的痛點：
*  不再需要繼承：不用複雜的類別階層。
*  不再需要類別和方法：純函數就好。
*  不再需要依賴注入框架：不用DI container，直接傳參數就是注入。
*  不再需要單例模式：避免全域狀態的問題。
*  不再需要private/public：所有依賴都是明確的資料，沒有隱藏。
*  測試超簡單：想mock哪個依賴？直接在測試時傳一個假的上下文進去就好。
作者還說，這是唯一你需要的模式，不管是微服務、編譯器、還是太空船系統，都能用它來結構化整個應用程式。

## 實際上這在哪裡常用？
這不是什麼全新發明，而是函數式程式設計的經典做法：
*  在Haskell或OCaml裡，常用「Reader Monad」來傳遞這樣的上下文（本質上就是把依賴打包傳下去）。
*  在Go語言裡，有些人會建一個AppContext或Dependencies struct，然後傳給各個handler或service。
*  類似概念也叫「Functional Dependency Injection」或「Reader Pattern」。
但作者只用了45分鐘Go就「發現」這個，暗示Go的簡潔讓他快速體會到這種模式的優點（相較於他之前用的複雜FP語言）。

總之，這是一個半開玩笑的「終極解決方案」，提醒我們：有時候最簡單的明確傳參數，就是最好的架構方式。如果你在寫程式時覺得依賴亂七八糟，不妨試試這個「Context Pattern」——保證讓你的程式更乾淨、更容易測試！